<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>
<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
	 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
			     file:///opt/casa/code/tools/xml/casa.xsd">
  
  
  
  
<tool name="simulator" module="simulator">
  <shortdescription>Tool for simulation</shortdescription>
  
  <code>
    <include>tools/synthesis/simulator_forward.h</include>
    <private>
      <include>tools/synthesis/simulator_private.h</include>
    </private>
  </code>
  
  <description> 
    
    simulator provides a unified interface for simulation of telescope
    processing.  It can create a MeasurementSet from scratch or read in an
    existing MeasurementSet, it can predict synthesis data onto the (u,v)
    coordinates or single dish data onto (ra,dec) points, and it can
    corrupt this data through Gaussian errors, an atmospheric model, or
    through specific errors residing in (anti-) calibration tables.
    
    In the observing phase, simulator creates a MeasurementSet and
    calculates uvw values. You first make a simulator tool, with the name
    of the MeasurementSet that you wish to construct. Next you use the
    various set* methods to set up the observing (antenna locations,
    sources, spectral windows, etc.). Then you call the observe method for
    each observing scan you wish to make, or observemany to create several
    scans. You specify the source name, spectral window name, and
    observing times. After this, you have a MeasurementSet that is
    complete but visibilities=0.
    
    In the prediction phase, you fill a MeasurementSet (either one newly
    created or a pre-existing one, perhaps from a real telescope) with
    data from a model or componentlist, and then corrupt the measurements
    (if desired).
    
    NOTE: sm.predict assumes model image units are Jy/pixel, and in fact
      will overwrite the brightness units of the image itself!

    The <link anchor="imager:imager.ft.function">ft</link> function of
    the <link anchor="imager:imager">imager</link> tool can also be used
    to calculate the model visibility for a model image
    or <link anchor="componentmodels">componentmodels</link>.
    
    To apply errors, first set up the various effects using the relevant
    set* methods, and then call corrupt.

    Some important details:
    - One call to observe generates one scan (all rows have the same SCAN_NUMBER).
    - The start and stop times specified to observe need not be contiguous and 
      so one can simulate antenna drive times or other gaps.
    - Currently there is only a rudimentary method to calculate patterns of 
      observing (mosaicing), since it is easy to do this via sequences of calls 
      of observe, or simutil::calcpointings, or the simobserve task
    - The heavy duty columns (DATA, FLAG, IMAGING_WEIGHT, etc. are tiled. New 
      tiles are generated for each scan. Thus the TSM files will not get very 
      large.
    - predict(incremental=False) calculates new visibilities and replaces the 
      DATA column,
    - predict(incremental=True) calculates new visibilities, adds them to the 
      DATA column
    - predict for any value of incremental then sets CORRECTED_DATA equal to 
      DATA, and MODEL_DATA to 1
  </description>
  
  

  
  
<method type="constructor" name="simulator">
  <shortdescription>Construct a simulator tool</shortdescription>
  <description>
    Create a simulator tool.
  </description>
  <returns type="simulatorobject">simulator tool</returns>
  <example>
    # create a simulator tool
    mysim = smtool();    
  </example>
</method>  



<method type="function" name="open">
  <shortdescription>Construct a simulator tool and create a new MeasurementSet</shortdescription>
  <description>
    A simulator tool can either operate on an existing MeasurementSet,
    predicting and/or corrupting data on the existing uvw coordinates 

    -- to do that open the MS with sm.openfromms(msname). 

    or it can be used to create a new MeasurementSet from descriptions of 
    the array configuration and the observational parameters 

    -- to create a new MS, use this method sm.open(msname).

    You will also need to run setconfig, setfield, setspw, setspwindow, 
    setfeed, and settimes.

    Creating the actual (empty) MS is accomplished with sm.observe.  
    Data can be subsequently sm.predict-ed and sm.corrupt-ed.  

    NOTE: sm.predict assumes the model image units are Jy/pixel, and 
      in fact will overwrite the brightness units of the image itself!
  </description>
  <input>    
    <param type="string" name="ms">
      <description>MeasurementSet to be created</description>
      <value></value>
    </param>
  </input>
  <returns type="bool">Boolean</returns>
  <example>    
    In this example, we read in the antenna coordinates from an ASCII file, 
    and simulate a single-pointing VLA observation with a calibrator. 
    Note that no primary beam attenuation will be applied (see sm.setvp).

    tabname = 'VLAC.LOCAL.TAB'
    asciifile = 'VLAC.LOCAL.STN'
    mytab=table.create()
    mytab.fromascii(tabname, asciifile);
    xx=[]; yy:=[]; zz:=[]; diam:=[];
    xx = mytab.getcol('X');  
    yy = mytab.getcol('Y');
    zz = mytab.getcol('Z');
    diam = mytab.getcol('DIAM');
    #
    sm.open('NEW1.ms')
    # do configuration
    posvla = me.observatory('vla');  #  me.observatory('ALMA') also works!
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
	         mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=posvla);

    # Initialize the spectral windows    
    sm.setspwindow(spwname='CBand', freq='5GHz',
		   deltafreq='50MHz',
		   freqresolution='50MHz',
		   nchannels=1,
		   stokes='RR RL LR LL');
    sm.setspwindow(spwname='LBand', freq='1.420GHz',
		   deltafreq='3.2MHz',
		   freqresolution='3.2MHz',
		   nchannels=32,
		   stokes='RR LL');
    
    # Initialize the source and calibrater
    sm.setfield(sourcename='My cal',
		sourcedirection=['J2000','00h0m0.0','+45.0.0.000'],
		calcode='A');
    sm.setfield(sourcename='My source',
		sourcedirection=['J2000','01h0m0.0','+47.0.0.000']);
  
    sm.setlimits(shadowlimit=0.001, elevationlimit='8.0deg');
    sm.setauto(autocorrwt=0.0);
    
    sm.settimes(integrationtime='10s', usehourangle=F, 
                referencetime=me.epoch('utc', 'today'));
    
    sm.observe('My cal', 'LBand', starttime='0s', stoptime='300s');
    sm.observe('My source', 'LBand', starttime='310s', stoptime='720s');
    sm.observe('My cal', 'CBand', starttime='720s', stoptime='1020s');
    sm.observe('My source', 'CBand', starttime='1030s', stoptime='1500s');
    
    sm.setdata(spwid=1, fieldid=1);
    sm.predict(imagename='M31.MOD');
    sm.setdata(spwid=2, fieldid=2);
    sm.predict(imagename='BigLBand.MOD');
    sm.close();    
  </example>
</method>

 
<method type="function" name="openfromms">
  <shortdescription>Construct a simulator tool using an already existing  MS</shortdescription> 
  <description>
    A simulator tool can either operate on an existing MeasurementSet,
    predicting and/or corrupting data on the existing uvw coordinates
    - to do that open the MS with sm.openfromms(msname)    
    or it can be used to create a new MeasurementSet from descriptions of
    the array configuration and the observational parameters.
    - to create a new MS, use sm.open(msname).
    
    NOTE: sm.predict assumes the model image units are Jy/pixel, and in
      fact will overwrite the brightness units of the image itself!
  </description>
  <input>
    
    <param type="string" name="ms">
      <description>MeasurementSet to be processed</description>
      <value></value>
      <choice>'MS'</choice>
    </param>
  </input>
  <returns type="bool"> Boolean</returns>
  <example>
    sm.openfromms('3C273XC1.MS');
    sm.predict('3C273XC1.imagename');
    sm.setnoise(simplenoise='10mJy');
    sm.setgain(interval='100s', amplitude=0.01);
    sm.corrupt();
    sm.close();
  </example>
</method>



 
<method type="function" name="close">
  <shortdescription>Close the simulator tool</shortdescription>
  <description>
    Close tools and write data to disk. This is a synonym for done.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="done">
  <shortdescription>Close the simulator tool</shortdescription>  
  <description>
    Close tools and write data to disk. This is a synonym for done.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="name">
  <shortdescription>Provide the name of the attached MeasurementSet</shortdescription>
  <description>
    Returns the name of the attached MeasurementSet.
  </description>
  <returns type="string">String</returns>
</method>


<method type="function" name="summary">
  <shortdescription>Summarize the current state</shortdescription>
  <description>
    Writes a summary of the currently set properties to the default logger.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="type">
  <shortdescription>Return the type of this tool</shortdescription>  
  <returns type="string">String or fail</returns>
  <description>
    This function returns the string `Simulator'.  It is used so that in a
    script, you can make sure this variable is a simulator tool.
  </description>
</method>



<method type="function" name="settimes">
  <shortdescription>Set integration time, etc.</shortdescription>
  <description>
    This method sets values to be used in sm.observe.  
    
    If usehourangle=False, the start and stop times in sm.observe are
    referenced to referencetime.
    
    If usehourangle=True, then in sm.observe, starttime/stoptime will be
    interpreted as startha/stopha.
    In that case, the start and stop times are calculated such that the
    start time is later than the reference time, but less than one day
    later.  The hour angles refer to the first source observed.
  </description>
  
  <input>    
    <param type="any" name="integrationtime">
      <description>Integration time</description>
      <any type="variant" /> 
      <value>10s</value>
    </param>
    
    <param type="bool" name="usehourangle">
      <description>Use starttime/stoptime as hour angles - else they are referenced to referencetime</description>
      <value>true</value>
    </param>
    
    <param type="any" name="referencetime">
      <description>Reference time for starttime and stoptime. Epoch Measure . E.g me.epoch('UTC', '50000.0d')
      </description>
      <any type="variant"/>
      <value>50000.0d</value>
      <choice>epoch measure</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="observe">
  <shortdescription>Observe a given configuration</shortdescription>
  
  <description>
    Observe a given source with a given spectral window for the specified
    times, including start, stop, integration, and gap times.
    
    If usehourangle=False (set with settimes), the start and stop times
    are referenced to referencetime.
    
    If userhourangle=True, starttime/stoptime are interpreted as
    startha/stopha, the start and stop times are calculated such that the
    start time is later than the reference time, but less than one day
    later, and the hour angles refer to the first source observed.
    
    setconfig, setspwindow, setfeed, and setfield must
    be run before observe can be run.
    
    See also sm.observemany 
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified)</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="string" name="spwname">
      <description>Unique user-supplied name for this spectral window</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="any" name="starttime">
      <description>Start time referenced to referencetime, or start hour angle</description>
      <any type="variant" />
      <value>0s</value>
    </param>
    
    <param type="any" name="stoptime">
      <description>Stop time referenced to referencetime, or stop hour angle</description>
      <any type="variant" />
      <value>3600s</value>
    </param>

    <param type="bool" name="add_observation">
      <description>Add a new line to the OBSERVATION subtable for this call</description>
      <value type="bool">false</value>
    </param>

    <param type="bool" name="state_sig">
      <description>a new line will be added to STATE if the following don't match</description>
      <value type="bool">true</value>
    </param>
    
    <param type="bool" name="state_ref">
      <value type="bool">false</value>
    </param>
    
    <param type="double" name="state_cal">
      <value>0.0</value>
    </param>
    
    <param type="double" name="state_load">
      <value>0.0</value>
    </param>
    
    <param type="int" name="state_sub_scan">
      <value>0</value>
    </param>
    
    <param type="string" name="state_obs_mode">
      <value>OBSERVE_TARGET.ON_SOURCE</value>
    </param>

    <param type="string" name="observer">
      <value>CASA simulator</value>
    </param>

    <param type="string" name="project">
      <value>CASA simulation</value>
    </param>

  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="observemany">
  <shortdescription>Observe a given configuration</shortdescription>
  
  <description>
    Observe given sources with a given spectral window for the specified
    times, including start, stop, integration, and gap times.
    
    If usehourangle=False (set with settimes), the start and stop times
    are referenced to referencetime.
    
    If userhourangle=True, starttime/stoptime are interpreted as
    startha/stopha, the start and stop times are calculated such that the
    start time is later than the reference time, but less than one day
    later, and the hour angles refer to the first source observed.
    
    See also sm.observe
  </description>
  <input>
    
    <param type="stringArray" name="sourcenames">
      <description>Name of sources</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="string" name="spwname">
      <description>Unique user-supplied name for this spectral window</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="stringArray" name="starttimes">
      <description>Start times referenced to referencetime, or start hour angle</description>
      <value>0s</value>
    </param>
    
    <param type="stringArray" name="stoptimes">
      <description>Stop time referenced to referencetime, or stop hour angle</description>
      <value>3600s</value>
    </param>
    
    <param type="stringArray" name="directions">
      <description></description>
      <value></value>
    </param>


    <param type="bool" name="add_observation">
      <description>Add a new line to the OBSERVATION subtable for this
      call</description>
      <value type="bool">false</value>
    </param>

    <param type="bool" name="state_sig">
      <description>a new line will be added to STATE if the following don't match</description>
      <value type="bool">true</value>
    </param>
    
    <param type="bool" name="state_ref">
      <value type="bool">false</value>
    </param>
    
    <param type="double" name="state_cal">
      <value>0.0</value>
    </param>
    
    <param type="double" name="state_load">
      <value>0.0</value>
    </param>
    
    <param type="int" name="state_sub_scan">
      <value>0</value>
    </param>
    
    <param type="string" name="state_obs_mode">
      <value>OBSERVE\_TARGET#ON\_SOURCE</value>
    </param>

    <param type="string" name="observer">
      <value>CASA simulator</value>
    </param>

    <param type="string" name="project">
      <value>CASA simulation</value>
    </param>

  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setlimits">
  <shortdescription>Set limits for observing</shortdescription>
  
  <description>
    Data are flagged for two conditions:
    
    - Below elevation limit: If either of the antennas point below the
    specified elevation limit then the data are flagged. The elevation is
    calculated correctly for antennas at different locations (such as
    occurs in VLBI).
    
    - Shadowing: If one antenna shadows another such that the fractional
    (geometric) blockage is greater than the specified limit then the data
    are flagged. No correction for blockage is made for shadowed but
    non-flagged points.
  </description>
  <input>
    
    <param type="double" name="shadowlimit">
      <description>Maximum fraction of geometrically shadowed area before flagging occurs</description>
      <value>1e-6</value>
      <choice>1e-6</choice>
    </param>
    
    <param type="any" name="elevationlimit">
      <description>Minimum elevation angle before flagging occurs</description>
      <any type="variant" />
      <value>10deg</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>






<method type="function" name="setauto">
  <shortdescription>Set autocorrelation weight</shortdescription>
  
  <description>
  </description>
  <input>
    
    <param type="double" name="autocorrwt">
      <description>Weight to assign autocorrelations (0=none)</description>
      <value>0.0</value>
      <choice>0.0</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>





<method type="function" name="setconfig">
  <shortdescription>Set the antenna configuration</shortdescription>
  
  <description>
    Set the positions of the antennas.  
    - The name of the telescope will control which voltage pattern 
      is applied to the data (see sm.setvp for details).
    - The diameter(s) will be written to the antenna subtable but 
      ONLY affect the calculated visibilities in sm.predict if 
      telescope=ALMA,ACA,OVRO, *and*  ftmachine=mosaic
      (see sm.setvp for details).
    - simutil::readantenna can be used to read an antenna config. file
      which includes many existing observatories.
      see help for the simobserve task, or the example below
  </description>
  <input>
    
    <param type="string" name="telescopename">
      <description>Name of the telescope we are simulating (determines VP)</description>
      <value>VLA</value>
      <choice>'VLA'</choice>
    </param>
    
    <param type="doubleArray" name="x">
      <description>Vector of x values of all antennas [m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="y">
      <description>Vector of y values of all antennas [m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="z">
      <description>Vector of z values of all antennas [m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="dishdiameter">
      <description>Vector of diameters of all antennas [m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="offset">
      <description>Vector of offset of all antennas [m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="mount">
      <description>Vector of mount types of all antennas (recognized mounts are 'ALT-AZ', 'EQUATORIAL', 'X-Y', 'ORBITING', 'BIZARRE'</description>
      <value>ALT-AZ</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="antname">
      <description>Vector of names of all antennas</description>
      <value>A</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="padname">
      <description>Vector of names of pads or stations</description>
      <value>P</value>
      <choice>[]</choice>
    </param>
    
    <param type="string" name="coordsystem">
      <description>Coordinate system of antenna positions [x,y,z], 
	possibilities are 'global', 'local' , 'longlat'</description>
      <value>global</value>
      <choice>'global'</choice>
    </param>
    
    <param type="any" name="referencelocation">
      <description>Reference location [required for local coords] Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', -20.2deg', 6000km') or  me.observatory('ALMA')
      </description>
      <any type="variant"/>
      <value>ALMA</value>
      <choice>position measure</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>

    # known antenna configurations are stored in the data repository, 
    # for historical reasons under "alma" even though this includes all
    # known observatories:
    configdir=casa.values()[0]['data']+"/alma/simmos/"

    # please look in that directory if your observatory is present.
    # if so, simutil can be used to read the file:
    from simutil import simutil
    # a simutil must be instantiated to use most methods
    u=simutil()
    x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+"vla.a.cfg")

    # note that readantenna converts the positions to earth-centered 
    # global, from whatever format is in the configuration file, so 
    # coordsystem="global" should be used in setconfig
    sm.setconfig(telescopename=telescope, x=x, y=y, z=z, 
                 dishdiameter=d.tolist(), 
                 mount=['alt-az'], antname=padnames,
                 coordsystem='global', referencelocation=pospbs);
  </example>
</method>




<method type="function" name="setfeed">
  <shortdescription>Set the feed parameters</shortdescription>
  
  <description>
    Specify feed parameters. At this moment, you only have the choice
    between 'perfect R L' and 'perfect X Y' (i.e., you cannot invent
    your own corrupted feeds yet).  Doesn't need to be run if you want
    perfect R and L feeds.
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode for specifying feed parameters (currently, perfect only)</description>
      <value></value>
    </param>
    <param type="doubleArray" name="x">
      <description> Some very secretive feed array parameter x</description>
      <value>0</value>
    </param>
    
    <param type="doubleArray" name="y">
      <description> Some more very secretive feed array parameter y
      </description>
      <value>0</value>
    </param>
    <param type="stringArray" name="pol">
      <description> 
      </description>
      <value>R</value>
      
    </param>
    
    
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setfield">
  <shortdescription>Set one or more observed fields</shortdescription>
  
  <description>
    Set one or more observed fields, including name and coordinates.
    Can be invoked multiple times for a complex observation.
    Must be invoked at least once before sm.observe.
    
    If the distance to the object is set then the phase term includes a
    curvature for the near-field effect at the center of the image.
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified)</description>
      <value>SOURCE</value>
      <choice>'unknown'</choice>
    </param>
    
    <param type="any" name="sourcedirection">
      <description>Direction Measure of Coordinates of source to be observed. E.g me.direction('J2000', '30.5deg','-20.2deg').
      </description>
      <any type="variant" />
      <value></value>
    </param>
    
    <param type="string" name="calcode">
      <description>Calibration code</description>
      <value></value>
      <choice>'OBJ'</choice>
    </param>
    
    <param type="any" name="distance">
      <description>Distance to the object</description>
      <any type="variant" />
      <value>0m</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    sm.setconfig(telescopename=telescope, x=x, y=y, z=z, 
                 dishdiameter=d.tolist(), 
                 mount=['alt-az'], antname=padnames,
                 coordsystem='global', referencelocation=pospbs);

    sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=1, stokes='RR
                   LL');
    dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
    sm.setfield(sourcename='SIMU1', sourcedirection=dir0);
    sm.settimes(integrationtime="10s", usehourangle=True, 
                referencetime=me.epoch('TAI', "2012/01/01/00:00:00"))
    sm.observe(sourcename='SIMU1', spwname='XBAND',
               starttime='0s', stoptime='3600s')

    
    
  </example>
</method>


<method type="function" name="setmosaicfield">
  <shortdescription>Set observed mosaic fields</shortdescription>
  
  <description>
    Set mosaic fields by internally invoking setfield multiple times.
    Currently only handle a rectangular mosaicing pattern.  Either
    setfield or setmosaicfield must be invoked at least once before
    observe.
    
    If the distance to the object is set then the phase term includes a
    curvature for the near-field effect at the center of the image.
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified).</description>
      <value>SOURCE</value>
      <choice>'unknown'</choice>
    </param>
    
    <param type="string" name="calcode">
      <description>Calibration code</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="fieldcenter">
      <description>Coordinates of mosaic field center</description>
      <any type="variant"/>
      <value></value>
      <choice>MDirection</choice>
    </param>
    
    <param type="int" name="xmosp">
      <description>Number of mosaic pointing in horizontal direction</description>
      <value>1</value>
    </param>
    
    <param type="int" name="ymosp">
      <description>Number of mosaic pointing in vertical direction</description>
      <value>1</value>
    </param>
    
    <param type="any" name="mosspacing">
      <description>Spacing between mosaic pointings</description>
      <any type="variant" />
      <value>1arcsec</value>
    </param>
    
    <param type="any" name="distance">
      <description>Distance to the object</description>
      <any type="variant" />
      <value>0m</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
                 mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=dm.observatory('vla'));
                                                                                
    sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=1, stokes='RR
                   LL');
    dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
    sm.setmosaicfield(sourcename='SIMU1', fieldcenter=dir0,
                      xmosp=2, ymosp=2, mosspacing='154.5arcsec');
    sm.settimes(integrationtime='10s');
    sm.observe('SIMU1_1', 'XBAND', starttime='0s', stoptime='100s');
    sm.observe('SIMU1_2', 'XBAND', starttime='110s', stoptime='210s');
    sm.observe('SIMU1_3', 'XBAND', starttime='220s', stoptime='320s');
    sm.observe('SIMU1_4', 'XBAND', starttime='330s', stoptime='430s');
    
    
  </example>
  In this example, a 2x2 mosaic pattern is set centered around the direction 
  specified (dir0). The setmosaicfield name each mosaic field with i
  sourcename+'_i', where i= 1..4.
</method>



 
<method type="function" name="setspwindow">
   <shortdescription>Set one or more spectral windows</shortdescription>
   
   <description>
     Set one or more spectral windows for the observations, including
     starting frequency, number of channels, channel increment and
     resolution, and stokes parameters observed.  Can be invoked
     multiple times for a complex observation.  Must be invoked at
     least once before observe.
   </description>
   <input>

     <param type="string" name="spwname">
     <description>Unique user-supplied name for this spectral window</description>
     <value>XBAND</value>
     <choice>'XBAND'</choice>
     </param>

     <param type="any" name="freq" >
     <description>Starting frequency</description>
     <any type="variant" />
     <value>8.0e9Hz</value>
     </param>

     <param type="any" name="deltafreq" >
     <description>Frequency increment per channel</description>
     <any type="variant" />
     <value>50e6Hz</value>
     </param>

     <param type="any" name="freqresolution" >
     <description>Frequency resolution per channel</description>
     <any type="variant" />
     <value>50.e6Hz</value>
     </param>

     <param type="string" name="refcode" >
     <description>Spectral reference code e.g. LSRK, TOPO, BARY</description>
     <value type="string">TOPO</value>
     <allowed kind="enum">
       <value type="string">LSRK</value>
       <value type="string">LSRD</value>
       <value type="string">BARY</value>
       <value type="string">GEO</value>
       <value type="string">TOPO</value>
       <value type="string">GALACTO</value>
       <value type="string">LGROUP</value>
       <value type="string">CMB</value>
     </allowed>
     </param>

     <param type="int" name="nchannels">
     <description>Number of channels</description>
     <value>1</value>
     </param>

     <param type="string" name="stokes">
     <description>Stokes types to simulate</description>
     <value>RR LL</value>
     <choice>'RR LL'</choice>
     </param>
</input>
<returns type='bool'>Bool</returns>
<example>

To simulate a two spectral window (or two IF's in VLA jargon) data
set, use setpwid as follows (here we are simulating 16 channels, 50MHz
wide channel for each spectral window)


sm.setspwindow(spwname='CBAND', freq='2GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=16, stokes='RR LL');

sm.setspwindow(spwname='SBAND', freq='5GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=16, stokes='RR LL');


Note that the spwname is used in observe to determine which spectral window
to use.

</example>
</method>


 
<method type="function" name="setdata">
  <shortdescription>Set the data parameters selection for subsequent processing</shortdescription>
  
  <description>
    This setup tool function selects which data are to be used
    subsequently. After invocation of setdata, only the selected data are
    operated on.
  </description>
  <input>
    
    <param type="intArray" name="spwid">
      <description>Spectral Window Ids (0 relative) to select</description>
      <value>0</value>
    </param>
    
    <param type="intArray" name="fieldid">
      <description>Field Ids (0 relative) to select</description>
      <value>0</value>
    </param>
    
    <param type="string" name="msselect">
      <description>TAQL select string applied as a logical "and" with the other selections</description>
      <value></value>
      <choice>String</choice>
    </param>
    
    
  </input>
  <returns type='bool'>Bool</returns>
</method>



 
<method type="function" name="predict">
  <shortdescription>Predict astronomical data from an image or components</shortdescription>
  
  <description>
    Predict astronomical data from an image.  The (u,v) coordinates
    already exist, either from a MeasurementSet we have read in or by
    generating the MeasurementSet coordinates and empty data through
    smobserve.  This method calculates visibilities for those
    coordinates.
    
    - predict(incremental=False) calculates new visibilities and
      replaces the DATA column,
    - predict(incremental=True) calculates new visibilities, adds
      them to the DATA column
    - predict for any value of incremental then sets CORRECTED_DATA
      equal to DATA, and MODEL_DATA to 1
    * predict assumes model image units are Jy/pixel, and in fact
      will overwrite the brightness units of the image itself!
    
    * treatment of primary beam depends critically on parameters set in 
      sm.setvp() and sm.setoptions(ftmachine) - see help sm.setvp for 
      details
    
  </description>
  <input>
    
    <param type="stringArray" name="imagename">
      <description>Name of image from which to predict visibilities</description>
      <value></value>
    </param>
    
    <param type="string" name="complist">
      <description>Name of component list</description>
      <value></value>
      <choice>String</choice>
    </param>
    
    <param type="bool" name="incremental">
      <description>Add this model to the existing Data Visibilities?</description>
      <value>false</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>

 
<method type="function" name="setoptions">
  <shortdescription>Set various processing options</shortdescription>
  
  <description>
    Set options for predict.  See also imager help.
    
    To simulate single dish data, use gridft=SD and gridfunction=PB.
    
    To invoke primary beam convolution in the uv domain, use
    ftmachine="mosaic".  This is the only option that allows
    heterogeneous array simulation - see the example below and 
    help sm.setvp for more details.
  </description>
  <input>
    
    <param type="string" name="ftmachine">
      <description>Fourier transform machine. Possibilities are 'ft', 'sd', 'mosaic'</description>
      <value>ft</value>
      <choice>'ft'</choice>
    </param>
    
    <param type="int" name="cache">
      <description>Size of gridding cache in complex pixels</description>
      <value>0</value>
    </param>
    
    <param type="int" name="tile">
      <description>Size of a gridding tile in pixels (in 1 dimension)</description>
      <value>16</value>
    </param>
    
    <param type="string" name="gridfunction">
      <description>Gridding function. String: 'SF'|'BOX'|'PB' </description>
      <value>SF</value>
      <choice>'SF'</choice>
    </param>
    
    <param type="any" name="location">
      <description>Location used in phase rotations. Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', '-20.2deg', '6000km') or  me.observatory('ALMA')
      </description>
      <any type="variant"/>
      <value>ALMA</value>
      <choice>position measure</choice>
    </param>
    
    <param type="double" name="padding">
      <description>Padding factor in image plane (\&gt;=1.0)</description>
      <value>1.3</value>
    </param>
    
    <param type="int" name="facets">
      <description>Number of facets</description>
      <value>1</value>
    </param>
    
    <param type="double" name="maxdata">
      <description>Maximum data to write to a single TSM file (MB)</description>
      <value>2000.0</value>
    </param>
    
    <param type="int" name="wprojplanes">
      <description>Number of projection planes when using wproject as the ft-machine </description>
      <value>1</value>
    </param>
    
  </input>
  <returns type="bool">Bool</returns>
  <example>
    # set some options
    sm.setoptions(cache=10000000, tile=32, gridfunction='BOX', me.location('vla'))

    
    # set ftmachine to invoke uv-domain primary beam convolution, and use that 
    # to simulate a heterogeneous ALMA 7m+12m array.
    from simutil import simutil
    u=simutil()
    configdir=casa.values()[0]['data']+"/alma/simmos/"
    x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+"alma.cycle5.1.cfg")
    x2,y2,z2,d2,padnames2,telescope2,posobs2 = u.readantenna(configdir+"aca.cycle5.cfg")
    
    sm.open("new.het.alma.ms")
    sm.setconfig(telescopename="ALMA",
      x=np.append(x,x2),y=np.append(y,y2),z=np.append(z,z2),
      dishdiameter=np.append(d,d2),
      mount=['alt-az'], padname=np.append(padnames,padnames2).tolist(),
      coordsystem='global', referencelocation=posobs)
    sm.setspwindow(spwname="band1", freq="330GHz",
      deltafreq="1GHz",freqresolution="1GHz",nchannels=1,stokes='XX YY')
    sm.setfeed(mode='perfect X Y',pol=[''])
    sm.setlimits(shadowlimit=0.01, elevationlimit='10deg')
    sm.setauto(0.0)
    sm.setfield(sourcename="src1", 
      sourcedirection="ICRS 10:00:00.00 -23.01.22",
      calcode="OBJ", distance='0m')
    sm.setfield(sourcename="src2", 
      sourcedirection="ICRS 10:00:00.00 -23.01.32",
      calcode="OBJ", distance='0m')
    sm.settimes(integrationtime="10s", usehourangle=True, 
      referencetime=me.epoch('TAI', "2012/01/01/00:00:00"))
    etime="600s"
    sm.observe(sourcename="src1", spwname="band1",
      starttime=qa.mul(-1,qa.quantity(etime)),
      stoptime=qa.quantity(0,"s"));
    sm.observe(sourcename="src2", spwname="band1",
      starttime=qa.quantity(0,"s"),
      stoptime=qa.quantity(etime));
    sm.setoptions(ftmachine="mosaic")
    sm.predict(imagename="point.ra10.image")
    sm.done()
  </example>

</method>




 
<method type="function" name="setvp">
  <shortdescription>Set the voltage pattern model for subsequent processing</shortdescription>
  
  <description>
    Set the voltage pattern model (and hence, the primary beam) used
    for a Telecope.  There are currently two ways to set the voltage
    pattern: by using the extensive list of defaults which the system
    knows about, or by creating a voltage pattern description with
    the <link anchor="imager:vpmanager">vpmanager</link>.  If you are
    simulating a telescope which doesn't yet exist, you will need to
    supply a model voltage pattern using
    the <link anchor="imager:vpmanager">vpmanager</link>.
    
    sm.predict behavior depends critically on the parameters here, and 
    the ftmachine parameter set in sm.setoptions
    
    sm.predict will always query the vpmanager for a primary beam/VP pattern. 
    if usedefaultvp==True, it will reset the vpmanager first, so that 
      the PB obtained will be the default for the given telescope name
    if usedefaultvp==False, it will check whether vptable is set, and if so, 
      load that table into the vpmanager and use the beams therein.
    if usedefaultvp==False and vptable is not set, it will use whatever is 
      already set in the vpmanager (see example below for overriding a 
      default telescope beam).
    
    What sm.predict does with the obtained PB depends on the ftmachine and 
    dovp parameters:
    
    if ftmachine=="mosaic":
    - a message "Performing Mosaic Gridding" indicates that one is using 
      uv domain convolution for simulating from images.
    - if the primary beam returned by the vpmanager is ALMA, ACA, or OVRO, 
      heterogeneous gridding will be invoked, and the dish diameter set
      in sm.setconfig, or already in the antenna subtable, will be used
      to convolve sky model images.
      for ALMA or ACA, dish diameter =12m will use a 10.7m Airy pattern, 
      and dish diameter =7m will use a 6.25m Airy pattern.
      see help sm.setoptions for an example.
    - otherwise the PB returned by the vpmanager will be used. 
    * heterogeneous simulation only works at present from a sky model
      image, NOT from sky model components. If you want to simulate a 
      heterogeneous array, please add components to an image using 
      ia.modify, and don't specify a component list in sm.predict.
      Homogeneous array simulation from component lists works fine.
    - IF dovp=True, the primary beam returned by the vpmanager will 
      be used to convolve sky model components.  This is not automatically 
      invoked by ftmachine="mosaic", but needs to be set explicitly with 
      sm.setvp() if you are simulating from components in addition to or 
      instead of sky model images.
       
    if ftmachine=="ft" (the default):
    - a message "Synthesis Gridding" indicates that if requested with 
      dovp==True, image domain PB convolution will be used.
    - if dovp==True, the primary beam returned by the vpmanager will be 
    used to convolve sky model components and images.
         
  </description>
  <input>
    
    <param type="bool" name="dovp">
      <description>Multiply by the voltage pattern (ie, primary beam) when simulating </description>
      <value>true</value>
    </param>
    
    <param type="bool" name="usedefaultvp">
      <description>Look up the default VP for this telescope and frequency?</description>
     <value>true</value>
    </param>
    
    <param type="string" name="vptable">
      <description>If usedefaultvp is false, provide a VP Table made with vpmanager</description>
      <value></value>
      <choice>Table</choice>
    </param>
    
    <param type="bool" name="dosquint">
      <description>Activate the beam squint in the VP model</description>
      <value>true</value>
    </param>
    
    <param type="any" name="parangleinc" >
      <description>Parallactice angle increment for squint application</description>
      <any type="variant" />
      <value>360deg</value>
    </param>
    
    <param type="any" name="skyposthreshold" >
      <description> Position threshold on the sky for feed arrays ??
      </description>
      <any type="variant" />
      <value>180deg</value>
    </param>
    <param type="double" name="pblimit">
      <description> Primary beam limit to use in feed arrays ?
      </description>
      <value>1.0e-2</value>
     </param>
    
  </input>
  <returns type="bool">Bool</returns>
  <example>
    # use the default primary beam in subsequent sm.predict (according to 
    # whatever telescope name was set in sm.setconfig)
    sm.setvp(dovp=True, usedefaultvp=True)
    sm.predict(imagename="point.ra10.image",complist="point.cl")
    
    # use an alternate VP table e.g. of the format created by vpmanager:
    sm.setvp(dovp=True, usedefaultvp=False, vptable='MyAlternateVLAPBModel.TAB', dosquint=F);
    sm.predict(imagename="point.ra10.image",complist="point.cl")
    
    # set a VP and then use it overridding the default
    # (if telescope="NGVLA" was used previously in setconfig, 
    # or if an MS was loaded with observatory name = "NGVLA")
    vp.setpbairy(telescope="NGVLA",dishdiam="10m",maxrad="5deg")
    sm.setvp(dovp=True,usedefaultvp=False)
    sm.predict(imagename="point.ra10.image",complist="point.cl")
    
  </example>
</method>



 
<method type="function" name="corrupt">
  <shortdescription>Corrupt the data with visibility errors</shortdescription>
  
  <description>
    Add errors specified by the set* functions (such as noise, gains,
    polarization leakage, bandpass, etc) to the visibility data.  The
    errors are applied to the DATA and CORRECTED_DATA columns.
<!--
MODEL_DATA, and written to the DATA and
    CORRECTED_DATA columns.  
-->
    Note that corrupt handles only
    visibility-plane effects, not image-plane effects such as pointing
    errors and voltage patterns, which get applied in predict.  Note, the
    function applies errors to both cross- and auto-correlation data; The
    auto-correlation data are corrupted properly only for the thermalnoise
    set by setnoise.
  </description>
  
  <returns type="bool">Boolean</returns>
  <example>
    
    sm,openfromms('3C273XC1.MS');
    sm.predict('3C273XC1.FAKE.IMAGE');
    sm.setnoise( mode='simplenoise', simplenoise='0.1Jy');
    sm.setpa( mode='calculate');
    sm.corrupt();
    
  </example>
</method>




<method type="function" name="reset">
  <shortdescription>Reset the corruption terms</shortdescription>   
  <description>
    Reset the visibility corruption terms: this means that corrupt
    introduces no errors.
  </description>
  <returns type="bool">Bool</returns>
</method>



<method type="function" name="setbandpass">
  <shortdescription>Set the bandpasses</shortdescription>
  
  <description>
    Set the level of bandpass errors. The error distributions are normal, mean
    zero, with the variances as specified. (Not yet implemented).
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation. String: 'calculate'|'table'</description>
      <value>calculate</value>
      <choice>'calculate'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Name of table</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="interval" >
      <description>Coherence interval e.g. '1h'</description>
      <any type="variant" />
      <value>3600s</value>
    </param>
    
    <param type="doubleArray" name="amplitude">
      <description>Variances errors in amplitude and phase</description>
      <value>0.0</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setapply">
  <shortdescription>Arrange for corruption by existing cal tables</shortdescription>
  
  <description>
    Arrange for corruption by existing cal tables, in a manner
    exactly analogous to calibrater.setapply.
  </description>
  <input>
    
    <param type="string" direction="in" name="table">
      <description>Calibration table name</description>
      <value></value>
    </param>
    
    <param type="string" direction="in" name="type">
      <description>Component type</description>
      <value>B</value>
      <value>BPOLY</value>
      <value>G</value>
      <value>GSPLINE</value>
      <value>D</value>
      <value>P</value>
      <value>T</value>
      <value>TOPAC</value>
      <value>GAINCURVE</value>
      <value></value>
    </param>
    
    <param type="double" direction="in" name="t">
      <description>Interpolation interval (seconds)</description>
      <value>0.0</value>
    </param>
    
    <param type="any" direction="in" name="field">
      <description>Select on field</description>
      <any type="variant"/>
      <value></value>
    </param>
    
    <param type="string" direction="in" name="interp">
      <description>Interpolation type (in time)</description>
      <value>aipslin</value>
      <value>nearest</value>
      <value>linear</value>
    </param>
    
    <param type="bool" direction="in" name="calwt">
      <description>Calibrate weights?</description>
      <value>false</value>
    </param>
    
    <param type="intArray" direction="in" name="spwmap">
      <description>Spectral windows to apply</description>
      <value>-1</value>
    </param>
    
    <param type="double" direction="in" name="opacity">
      <description>Array-wide zenith opacity (for type='TOPAC')</description>
      <value>0.0</value>
    </param>
    
  </input>
  <returns type='bool'>Bool</returns>
</method>

<method type="function" name="setgain">
  <shortdescription>Set the gains</shortdescription>
  
  <description>
    Set the level of gain errors.  Gain drift is implemented as
    fractional brownian motion with rms amplitude as specified.
    Interval is not currently used.
    <!-- , but future statistical models for gain errors (e.g. simple Gaussian) will use it. -->
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation. String: 'fbm'</description>
      <value>fbm</value>
      <choice>'fbm'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Optional name of table to write</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="interval" >
      <description>timescale for gain variations NOT USED</description>
      <any type="variant" />
      <value>10s</value>
    </param>
    
    <param type="doubleArray" name="amplitude">
      <description>amplitude scale (RMS) for gain variations [real,imag] or scalar</description>
      <value>0.01</value>
      <choice>[]</choice>
    </param>
    
  </input>
  <returns type='bool'>Bool</returns>
</method>



<method type="function" name="settrop">
  <shortdescription>Set tropospheric gain corruptions</shortdescription>
  
  <description>
    Set up for corruption by the atmosphere - attenuation and increase in 
    noise.
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation - screen or individual antennas</description>
      <value>screen</value>
      <choice>'screen'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Name of optional cal table to write</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="double" name="pwv">
      <description>total precipitable water vapour in mm</description>
      <value>3.0</value>
    </param>
    
    <param type="double" name="deltapwv">
      <description>RMS PWV fluctuations *as a fraction of PWV parameter*</description>
      <value>0.15</value>
    </param>
    
    <param type="double" name="beta">
      <description>exponent of fractional brownian motion</description>
      <value>1.1</value>
    </param>
    
    <param type="double" name="windspeed">
      <description>wind speed for screen type corruption (m/s)</description>
      <value>7.</value>
    </param>
    
  </input>
  <returns type='bool'>Bool</returns>
</method>




<method type="function" name="setpointingerror">
  <shortdescription>Set the Pointing error</shortdescription>
  
  <description>
    Set the pointing error from a calpointing table
  </description>
  <input>
    
    <param type="string" name="epjtablename">
      <description>Name of a table that has E-Jones errors for Pointing
      </description>
      <value></value>
    </param>
    
    <param type="bool" name="applypointingoffsets">
      <description>Apply pointing offsets</description>
      <value>false</value>
    </param>
    
    <param type="bool" name="dopbcorrection">
      <description>apply primary beam correction</description>
      <value>false</value>
    </param>
    
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setleakage">
  <shortdescription>Set the polarization leakage</shortdescription>
  
  <description>
    Set the level of polarization leakage between feeds.
    Currently, no time dependence is available.
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation. String: 'constant'</description>
      <value>constant</value>
      <choice>'constant'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Optional name of table to write</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <!--
	<param type="any" name="interval" >
	  <description>Coherence interval e.g. '5.0h'</description>
	  <any type="variant" />
	  <value>18000s</value>
	</param>
	-->
    
    <param type="doubleArray" name="amplitude">
      <description>Magnitude of pol leakage [real,imag]</description>
      <value>0.01</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="offset">
      <description>Meam of pol leakage [real,imag]</description>
      <value>0.</value>
      <choice>[]</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="oldsetnoise">
  <shortdescription>Set the noise level fixed sigma (mode=simplenoise) or
    Brown's equation (mode=calculate) OBSOLETE VERSION</shortdescription>
  
  <description>
    Set various system parameters from which the thermal (ie, random
    additive) noise level will be calculated.
    
    For mode=simplenoise, one specifies the standard deviation for the
    noise to be added to real and imaginary parts of the visibility.
    
    For mode=calculate, the noise will vary with dish diameter,
    antenna efficiency, system temperature, opacity, sky temperature,
    etc.  The noise will increase with the airmass if tau is greater
    than zero.  The noise is calculated according to the Brown
    Equation (ie, R.L. Brown's calculation of MMA sensitivity,
    3Oct95): 
    dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) + 
                      T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
                   *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)
  </description>
  <input>

    <param type="string" name="mode">
      <description>Mode of operation. String: 'simplenoise'|'calculate' 
      </description>
      <value>calculate</value>
      <choice>'simplenoise'</choice>
      <choice>'calculate'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Name of noise table - not currently implemented</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="simplenoise" >
      <description>Level of noise (if mode=simplenoise)</description>
      <any type="variant" />
      <value>0.0Jy</value>
    </param>
    
    <param type="double" name="antefficiency">
      <description>antenna efficiency</description>
      <value>0.8</value>
      <choice>0.8</choice>
    </param>
    
    <param type="double" name="correfficiency">
      <description>Correlation efficiency</description>
      <value>0.85</value>
      <choice>0.85</choice>
    </param>
    
    <param type="double" name="spillefficiency">
      <description>Forward spillover efficiency</description>
      <value>0.85</value>
      <choice>0.85</choice>
    </param>
    
    <param type="double" name="tau">
      <description>Atmospheric Opacity</description>
      <value>0.1</value>
      <choice>0.1</choice>
    </param>
    
    <param type="double" name="trx">
      <description>Receiver temp (ie, all non-atmospheric Tsys contributions) [K]</description>
      <value>50</value>
      <choice>50</choice>
    </param>
    
    <param type="double" name="tatmos">
      <description>(Physical, not Brightness) Temperature of atmosphere [K]</description>
      <value>230.0</value>
      <choice>230.0</choice>
    </param>
    
    <param type="double" name="tcmb">
      <description>Temperature of cosmic microwave background [K]</description>
      <value>2.7</value>
      <choice>2.7</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>




<method type="function" name="setnoise">
  <shortdescription>Set the noise level fixed sigma (mode=simplenoise) or
    Brown's equation using the ATM model for frequency-dependent atmospheric
    opacity (mode=tsys-atm) or Brown's equation, manually specifying the zenith
    opacity (constant across the band) and atmospheric temperature 
    (mode=tsys-manual)</shortdescription>

  <description>
    Set various system parameters from which the thermal (ie, random
    additive) noise level will be calculated.
    
    For mode=simplenoise, one specifies the standard deviation "sigma"
    for the noise to be added to real and imaginary parts of the visibility.
    The noise in amplitude per visibility is approximately "sigma" although 
      it is not Gaussian (see Thompson, Moran, and Swenson fig. 6.9)
    and the point source noise in a Stokes I image will be 
      ~sigma/sqrt(n_pol)/sqrt(n_baselines)/sqrt(n_integrations), 
    where n_pol are the number of polarizations in the MS (typically 2),
    and n_integrations are the number of correlator integration times 
    in the MS (~ track time / int. time)
    
    For mode=tsys-atm or tsys-atm, the noise will vary with dish
    diameter, antenna efficiency, system temperature, opacity, sky
    temperature, etc.  The noise will increase with the airmass if tau
    is greater than zero.  The noise is calculated according to the
    Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity,
    3Oct95):
    dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) + 
                      T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
                   *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)


    For mode=tsys-atm, the sky brightness temperature is calculated
    using an atmospheric model created for the user-input PWV.  For
    mode=tsys-manual, the user specifies the sky brightness temperature
    manually.
  </description>
  
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation.</description>
      <value>simplenoise</value>
      <choice>'simplenoise'</choice>
      <choice>'tsys-atm'</choice>
      <choice>'tsys-manual'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Name of optional cal table to write (if OTF=False)</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="simplenoise" >
      <description>Level of noise if not calculated by amt</description>
      <any type="variant" />
      <value>0.1Jy</value>
    </param>
    
    <param type="any" name="pground" >
      <description>Ground pressure for ATM model (if tsys-atm)</description>
      <any type="variant" />
      <value>560mbar</value>
    </param>
    
    <param type="double" name="relhum">
      <description>ground relative humidity for ATM model (if tsys-atm)</description>
      <value>20.0</value>
    </param>
    
    <param type="any" name="altitude" >
      <description>site altitude for ATM model (if tsys-atm)</description>
      <any type="variant" />
      <value>5000m</value>
    </param>
    
    <param type="any" name="waterheight" >
      <description>Height of water layer for ATM model (if tsys-atm)</description>
      <any type="variant" />
      <value>200m</value>
    </param>
    
    <param type="any" name="pwv" >
      <description>Precipitable Water Vapor ATM model (if tsys-atm)</description>
      <any type="variant" />
      <value>1mm</value>
    </param>
     
    <param type="double" name="tatmos">
      <description>Temperature of atmosphere [K] (if tsys-manual)</description>
      <value>250.0</value>
    </param>
    
    <param type="double" name="tau">
      <description>Zenith Atmospheric Opacity (if tsys-manual)</description>
      <value>0.1</value>
    </param>
    
    <param type="double" name="antefficiency">
      <description>Antenna efficiency</description>
      <value>0.8</value>
    </param>
    
    <param type="double" name="spillefficiency">
      <description>Forward spillover efficiency</description>
      <value>0.85</value>
    </param>
    
    <param type="double" name="correfficiency">
      <description>Correlation efficiency</description>
      <value>0.88</value>
    </param>
    
    <param type="double" name="trx">
      <description>Receiver temp (ie, all non-atmospheric Tsys contributions) [K]</description>
      <value>50</value>
    </param>
    
    <param type="double" name="tground">
      <description>Temperature of ground/spill [K]</description>
      <value>270.0</value>
    </param>
    
    <param type="double" name="tcmb">
      <description>Temperature of cosmic microwave background [K]</description>
      <value>2.73</value>
    </param>
    
    <param type="bool" name="OTF">
      <description>calculate noise on-the-fly (WARNING: only experts with high-RAM machines should use False)</description>
      <value type="bool">true</value>
    </param>
    
    <param type="double" name="senscoeff">
      <description>sensitivity constant (1./sqrt(2) for interferometer [default]; 1. for total power)</description>
      <value>0.</value>
    </param>
    
    <param type="int" name="rxtype">
      <description>Receiver type; 0=2SB, 1=DSB e.g. ALMA B9</description>
      <value>0</value>
    </param>
    
  </input>
  <returns type='bool'>Bool</returns>
</method>



<method type="function" name="setpa">
  <shortdescription>Corrupt phase by the parallactic angle</shortdescription>
  
  <description>
    Corrupt phase by the parallactic angle
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode of operation. String: 'calculate'|'table'</description>
      <value>calculate</value>
      <choice>'calculate'</choice>
    </param>
    
    <param type="string" name="table">
      <description>Name of table</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="interval" >
      <description>Interval for parallactic angle application, e.g. '10s'</description>
      <any type="variant" />
      <value>10s</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setseed">
  <shortdescription>Set the seed for the random number generator</shortdescription>
  
  <description>
    
  </description>
  <input>
    
    <param type="int" name="seed">
      <description>Seed</description>
      <value>185349251</value>
      <choice>185349251</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>

</tool>


</casaxml>
